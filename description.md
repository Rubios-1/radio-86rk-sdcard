# Описание работы проекта 86RKSD от автора - Алексея Морозова (по материалам статей в vk.com)

Этот проект очень давно начат и много раз забрасывался. И я возвращаюсь очередной раз. Мы будем подключать флешку к компьютеру Радио 86РК, а точнее подключать к компьютеру микроконтроллер ATMega8 к которому подключена флешка.

### Зачем микроконтроллер? 

Почему бы просто карту памяти не подключить? А вот зачем:

Где то надо хранить программу, которая будет работать с картой памяти. Программа прошитая в ПЗУ компьютера умеет загружать программы только с магнитофона или ПЗУ подключенного к параллельному порту.

Микроконтроллер будет эмулировать внешнее ПЗУ. После включения компьютера, микроконтроллер читает с карты памяти файл и притворяется ПЗУ содержащим эти данные. Компьютер копирует эти данные в память и запускает.

Это только первый этап работы. Дальше пользователь должен увидеть список файлов на экране и иметь возможность как минимум запустить нужный файл. Это уже не эмуляция ПЗУ, это весьма сложная программа, которую раньше называли - дисковая операционная система.

Эта система заняла бы половину памяти компьютера, это бы не позволило запустить большинство программ. И система бы работала бы очень медленно. И сбой компьютера мог бы привести к уничтожению данных на флешке.

Поэтому я решил разместить операционную систему в микроконтроллере. Это быстрее, надежнее и это экономит ресурсы компьютера.

У микроконтроллера **ATMega8** всего **1 Кб ОЗУ** и **8 Кб ПЗУ**. Мне пришлось сильно напрячь голову, что бы написать ОС способную работать на таких скромных объемах.

### Плата

Обобщая написанное. Плата подключается к параллельному порту компьютера. На плате находится микроконтроллер, внутри которого находится эмулятор ПЗУ. Загрузить программу из ПЗУ можно с помощью стандартной директивы **R0,100 G**. Загруженная программа уже будет работать с операционной системой внутри микроконтроллера.

Помимо микроконтроллера и слота для карты, на плате еще несколько деталей для согласования карты с компьютером. Компьютер работает с напряжением **5 Вольт**, а карта памяти **3.3 Вольта**.

### Программа эмуляции ПЗУ

Писать пришлось на ассемблере, так как программа на **Си** не успевала. Компилятор **CodeVision AVR** находится в режиме оптимизации размера в ущерб скорости. Если выключить этот режим, то программа не помещается в микроконтроллер.

Ничего сложного, но заставить все это работать вместе оказалось не так просто (не так быстро). Начинаем писать:

```
// Шина данных на выход

#define DATA_OUT DDRC = 0b00111111, DDRB = 0b11101101;

// Шина данных на вход

#define DATA_IN DDRD = 0x00000000, DDRB = 0b00101101;

void main() {

  DDRD = 0;    // Шина адреса на вход

  DATA_OUT // Шина данных на выход. а так же настраиваем остальные выводы.

  PORTB = 0b00010000; // Подтягивающий резистор на MISO

  // Пауза, пока не стабилизируется питание

  delay_ms(100);

  // Запуск файловой системы

  if(fs_init()) error();

  // Открываем файл boot/boot.rk

  strcpyf(buf, "boot/boot.rk");

  if(fs_open()) error();

  // Он должен быть не больше 128 байт

  if(fs_getfilesize()) error();

  if(fs_tmp > 128) error();

  // Чиатем его в массив rom

  if(fs_read0(rom, (WORD)fs_tmp)) error();

    // Эмуляция ПЗУ

  while(1) {

#asm

        IN   R30, PIND          ; Получаем адрес от компьютера в R30

        LDI  R31, 1               ; Массив rom находится по адресу 0x100. Записываем в R31 единицу.

        LD   R30, Z               ; Читаем в R30 из адреса R31:R30

        OUT  PORTC, R30         ; Отдаем младшие 6 бит компьютеру

        IN   R31, PORTB         ; Отдаем старшие 2 бита компьютеру

        ANDI R31, 0x3F

        ANDI R30, 0xC0

        OR   R31, R30

        OUT  PORTB, R31

#endasm

  }

}
```

###Переключение из режима эмуляции ПЗУ в режим общения с микроконтроллером

Следующим этапом будет переключение из режима эмуляции ПЗУ в режим полноценного общения с микроконтроллером.

Для выхода из этого режима надо последовательно прочитать ячейки ПЗУ: **19, 23, 87**. После этого на шине данных должен появится байт **40h** (константа **ERR_START**).

1). ПРОЧИТАТЬ ДАННЫЕ ПО **АДРЕСУ 19**

2). ПРОЧИТАТЬ ДАННЫЕ ПО **АДРЕСУ 23**

3). ПРОЧИТАТЬ ДАННЫЕ ПО **АДРЕСУ 87**

Далее микроконтроллер будет отдавать данные по тактовому импульсу. В качестве тактового импульса используется линия адреса **A0**. Что бы прочитать или передать очередной байт, надо обратится по адресам **86, 87**. Чтение любого другого адреса вызовет перезагрузку контроллера и возврат в режим **эмуляции ПЗУ**.

После **ERR_START (40h)**, микроконтроллер передает байт **ERR_OK_WAIT (41h)**. И будет передавать его, пока проверяет наличие карты памяти и инициализирует файловую систему. Если инициализация прошла без ошибок, микроконтроллер передает байт **ERR_OK_DISK (42h)**.

4). ЕСЛИ ПРОЧИТАННЫЕ ДАННЫЕ **40h**, РАБОТАЕМ ДАЛЬШЕ

5). ПРОЧИТАТЬ ДАННЫЕ ПО АДРЕСУ **86**

6). ПРОЧИТАТЬ ДАННЫЕ ПО АДРЕСУ **87**

7). ЕСЛИ ПРОЧИТАННЫЕ ДАННЫЕ **41h**, ПЕРЕЙТИ НА ПУНКТ 5

8). ЕСЛИ ПРОЧИТАННЫЕ ДАННЫЕ **42h**, РАБОТАЕМ ДАЛЬШЕ

Дальше, компьютер должен переключить шину данных на передачу, а микроконтроллер на прием. Если компьютер и контроллер одновременно переключатся в режим передачи, произойдет короткое замыкание. Что бы такого не было, переключение в режим передачи происходит в два такта.

Сначала компьютер дергает тактовый сигнал. Микроконтроллер переключается в режим приема. В этот момент времени на шине нет передающего устройства и соответственно в этот такт данные не передаются. Потом компьютер переключается в режим передачи и выставляет передаваемые данные на шину. И только после этого дергает тактовый сигнал и микроконтроллер читает данные.

9). ПРОЧИТАТЬ ДАННЫЕ ПО АДРЕСУ **86**

10). ПРОЧИТАТЬ ДАННЫЕ ПО АДРЕСУ **87**

11). ПЕРЕКЛЮЧИТЬ КОМПЬЮТЕР В РЕЖИМ ПЕРЕДАЧИ

Сейчас мы передаем все данные для команды. Код команды и её аргументы. После передачи каждого байта мы дергаем тактовую линию.

12). ПЕРЕДАТЬ БАЙТ **0** (это команда загрузки файла **sdbios.rk**)

13). ПРОЧИТАТЬ ДАННЫЕ ПО АДРЕСУ **86**

14). ПРОЧИТАТЬ ДАННЫЕ ПО АДРЕСУ **87**

После передачи команды надо опять поменять направление передачи. Микроконтроллер сохраняет данные сразу же по перепаду тактового импульса. Микроконтроллер быстрее компьютера в 20 раз. Поэтому мы можем сразу же после передачи байта переключить компьютер в режим приема. И дернуть тактовый импульс, микроконтроллер переключит шину в режим передачи и выставит передаваемый байт.

15). ПЕРЕКЛЮЧИТЬ КОМПЬЮТЕР В РЕЖИМ ПРИЕМА

16). ПРОЧИТАТЬ ДАННЫЕ ПО АДРЕСУ **86**

17). ПРОЧИТАТЬ ДАННЫЕ ПО АДРЕСУ **87**

18). ЕСЛИ ПРОЧИТАННЫЕ ДАННЫЕ **41h**, ПЕРЕЙТИ НА ПУНКТ 16

19). ЕСЛИ ПРОЧИТАННЫЕ ДАННЫЕ **47h**, РАБОТАЕМ ДАЛЬШЕ

20). ПРИНИМАЕМ И ЗАПУСКАЕМ ФАЙЛ

**Код 47** значит, что файл найден и загружен. Можно начать его прием.

Теперь надо заставить это работать.

Написал программу. Проблема была только с тем, что при переключении режима порта (прием/передача), все линии порта сбрасываются в ноль. Пришлось для тактового сигнала выбрать значения 0 и 1. И волшебная комбинация перехода стала **84h, 80h, 0h**.

Работает :)

###SDBIOS

Теперь надо адаптировать SDBIOS. Это маленькая программа, которая загружается в память во вторую очередь и содержит все функции для работы с флешкой.

Программам использующим флешку не надо самим лезть в порты и соблюдать протокол передачи. Надо просто вызвать функцию этого **SDBIOS**. Помимо упрощения жизни, этот SDBIOS позволит (если потребуется) использовать вместо флешки любой контроллер и любой накопитель.

У используемого микроконтроллера всего 1 Кб оперативной памяти. Поэтому файл в компьютер перегружается блоками по 512 байт.

20). ПРИНИМАЕМ И ЗАПУСКАЕМ ФАЙЛ в действительности достаточно сложный. Я не буду писать ПРОЧИТАТЬ ДАННЫЕ ПО АДРЕСУ 1, 0, что бы сократить текст

21). ПОЛУЧАЕМ АДРЕС ЗАГРУЗКИ ФАЙЛА (2 байта)

22). ЖДЕМ ПОКА КОНТРОЛЛЕР ПЕРЕДАЕТ ERR_WAIT

23). ЕСЛИ МЫ ПРИНЯЛИ **ERR_OK_READ**, ТО ФАЙЛ ПОЛНОСТЬЮ ЗАГРУЖЕН БЕЗ ОШИБОК И МЫ ЕГО ЗАПУСКАЕМ

24). ЕСЛИ МЫ ПРИНЯЛИ НЕ 0, ВЫХОДИМ С ОШИБКОЙ.

25). ПОЛУЧАЕМ ДЛИНУ БЛОКА (2 байта)

26). ПОЛУЧАЕМ БЛОК ДАННЫХ И ЗАПИСЫВАЕМ ЕГО В ПАМЯТЬ

27). ПЕРЕХОДИМ НА 22

####Запуск файла

Но никому с этим парится не придется. Для запуска любого файла надо лишь занести его имя в регистр HL и вызвать подпрограмму Exec.

```
MVI A, 0 ; Код команды

LXI H, FILENAME

CALL SDBIOS
```

####Изменения

поменял используемые выводы микроконтроллера, что позволило упростить программу, поднять скорость работы и надежность.

До этого шина данных компьютера была разбита на два порта микроконтроллера и при записи приходилось выполнять медленную программу

````
PORTC = d;

PORTD = (PORTD & 0x3F) | (d & 0xC0);
````

Теперь же медленный способ используется для шины адреса. А шина адреса используется только на чтение и только эмулятором ПЗУ, который нужен только для начальной загрузки. После загрузки общение происходит исключительно через шину данных и она теперь не тормозит.

###Резюме

Плата контроллер подойдет к любому **Радио 86РК**. А так же другим компьютерам с **ВВ55**-ым портом и поддерживающим загрузку с ПЗУ подключенному к этому порту. Например: Ориону, Корвету.

Только для разных компьютеров будет разных набор файлов на флешке. Для различных Радио 86РК они будут отличаться адресами загрузки и портов.

